<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Potencial El√©trico Interativo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #00416A 0%, #799F0C 100%);
            min-height: 100vh;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            align-items: start;
        }

        /* Avatar Container (sem altera√ß√µes) */
        #avatar-container {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.5);
            z-index: 1000;
            width: 100%;
            border: 3px solid #FF8C00;
            position: sticky;
            top: 20px;
        }

        #avatar-icon { width: 120px; height: 120px; margin: 0 auto 15px; display: block; }
        .avatar-body { animation: float 3s ease-in-out infinite; }
        .avatar-eye { animation: blink 4s linear infinite; }
        #avatar-mouth { transform-origin: center; transition: transform 0.2s; }
        #avatar-container.speaking #avatar-mouth { animation: talk 0.3s linear infinite; }
        #avatar-container.speaking .lightning { animation: zap 0.3s ease-in-out infinite alternate; }
        #avatar-container.speaking .control-light { animation: blink-light 0.5s linear infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
        @keyframes blink { 0%, 95%, 100% { transform: scaleY(1); } 97.5% { transform: scaleY(0.1); } }
        @keyframes talk { 0%, 100% { transform: scaleY(0.3); } 50% { transform: scaleY(1); } }
        @keyframes zap { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0.6; transform: scale(1.15); } }
        @keyframes blink-light { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        #avatar-title { color: #333; text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 10px; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5); }
        #avatar-status { color: #555; text-align: center; font-size: 13px; margin-bottom: 15px; min-height: 20px; font-weight: 500; }

        .avatar-btn { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 10px; background: white; color: #FF8C00; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 14px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2); }
        .avatar-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); }
        .avatar-btn:active { transform: translateY(0); }
        .avatar-btn.stop { background: #ff4757; color: white; }
        .avatar-btn.add-charge { background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; }

        /* Main Container */
        .container { width: 100%; }
        h2 { text-align: center; color: white; margin-bottom: 15px; /* Reduzido */ font-size: 32px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
        
        /* === Estilos para os links de navega√ß√£o === */
        .navigation-links {
            text-align: center;
            margin-bottom: 25px; /* Aumentado */
        }
        .navigation-links a {
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 8px 15px;
            border-radius: 15px;
            text-decoration: none;
            margin: 0 10px;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }
        .navigation-links a:hover {
            background-color: rgba(0, 0, 0, 0.4);
        }
        /* === Fim dos estilos para links === */

        .main-content { display: flex; gap: 20px; flex-wrap: wrap; }
        .simulation-panel, .flowchart-panel { flex: 1; background: white; border-radius: 20px; padding: 30px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); }
        .simulation-panel { min-width: 600px; }
        .flowchart-panel { min-width: 400px; }
        canvas { border: 2px solid #e0e0e0; border-radius: 10px; display: block; margin: 0 auto 20px; background: #f8f9fa; width: 100%; height: auto; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 20px; }
        .control-group { background: #f8f9fa; padding: 15px; border-radius: 10px; }
        .control-group.charge3 { background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 2px solid #2ecc71; }
        .control-group h3 { margin-bottom: 10px; font-size: 16px; }
        .control-group.charge1 h3 { color: #ff4757; }
        .control-group.charge2 h3 { color: #3742fa; }
        .control-group.charge3 h3 { color: #27ae60; }
        label { display: flex; justify-content: space-between; align-items: center; margin: 10px 0 5px; color: #333; font-size: 14px; font-weight: 500; }
        input[type="range"] { width: 100%; }
        .value-display { font-weight: bold; }
        #pauseBtn { grid-column: 1 / -1; padding: 12px; margin-top: 15px; border: none; border-radius: 10px; background: linear-gradient(135deg, #0052D4 0%, #4364F7 50%, #6FB1FC 100%); color: white; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        #pauseBtn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(67, 100, 247, 0.4); }
        .hidden { display: none; }
        .flowchart-panel h3 { color: #00416A; margin-bottom: 20px; font-size: 24px; text-align: center; }
        .flow-step { background: #f8f9fa; border-left: 4px solid #799F0C; padding: 15px 20px; margin: 25px auto; border-radius: 0 8px 8px 0; position: relative; max-width: 90%; text-align: center; }
        .flow-step::after { content: '‚Üì'; position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%); font-size: 24px; color: #ccc; font-weight: bold; }
        .flow-step:last-child::after { content: ''; }
        .flow-step strong { color: #00416A; display: block; margin-bottom: 8px; font-size: 1.1em; }
        .flow-step p { font-size: 14px; line-height: 1.6; color: #555; }
        @media (max-width: 1200px) { body { grid-template-columns: 1fr; } #avatar-container { position: static; max-width: 100%; margin-bottom: 20px; } }
        @media (max-width: 768px) { .simulation-panel, .flowchart-panel { min-width: 100%; } }
    </style>
</head>
<body>
    <div id="avatar-container">
        <svg id="avatar-icon" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="bodyGradient" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" /><stop offset="100%" style="stop-color:#FFA500;stop-opacity:1" /></linearGradient><radialGradient id="eyeGlow" cx="50%" cy="50%" r="50%"><stop offset="0%" style="stop-color:#00FFFF;stop-opacity:1" /><stop offset="100%" style="stop-color:#0080FF;stop-opacity:1" /></radialGradient></defs><g class="avatar-body"><rect x="25" y="30" width="70" height="60" rx="12" fill="url(#bodyGradient)" stroke="#FF8C00" stroke-width="3"/><line x1="60" y1="30" x2="60" y2="15" stroke="#FF8C00" stroke-width="3" stroke-linecap="round"/><circle cx="60" cy="12" r="5" fill="#FF4500" class="control-light"/><circle cx="45" cy="50" r="10" fill="white" class="avatar-eye" stroke="#333" stroke-width="2"/><circle cx="75" cy="50" r="10" fill="white" class="avatar-eye" stroke="#333" stroke-width="2"/><circle cx="45" cy="50" r="6" fill="url(#eyeGlow)"/><circle cx="75" cy="50" r="6" fill="url(#eyeGlow)"/><circle cx="47" cy="48" r="2" fill="white"/><circle cx="77" cy="48" r="2" fill="white"/><rect x="45" y="68" width="30" height="6" rx="3" fill="#333" id="avatar-mouth"/><rect x="45" y="78" width="30" height="8" rx="2" fill="#333" opacity="0.3"/><circle cx="50" cy="82" r="2" fill="#00FF00" class="control-light"/><circle cx="60" cy="82" r="2" fill="#FFFF00" class="control-light"/><circle cx="70" cy="82" r="2" fill="#FF0000" class="control-light"/><path class="lightning" d="M 20 45 L 15 50 L 20 50 L 15 60 L 25 50 L 20 50 Z" fill="#FFFF00" stroke="#FFA500" stroke-width="1.5"/><path class="lightning" d="M 100 45 L 105 50 L 100 50 L 105 60 L 95 50 L 100 50 Z" fill="#FFFF00" stroke="#FFA500" stroke-width="1.5"/></g></svg>
        <div id="avatar-title">‚ö° Professor Volt ‚ö°</div>
        <div id="avatar-status">Pronto para ensinar!</div>
        <button class="avatar-btn" onclick="explainSimulation()">üìö Explicar Simula√ß√£o</button>
        <button class="avatar-btn" onclick="explainFlowchart()">üìä Explicar Fluxograma</button>
        <button class="avatar-btn add-charge" id="addChargeBtn" onclick="toggleThirdCharge()">‚ûï Adicionar 3¬™ Carga</button>
        <button class="avatar-btn stop" onclick="stopSpeaking()">‚èπÔ∏è Parar</button>
    </div>

    <div class="container">
        <h2>üó∫Ô∏è Simulador de Potencial El√©trico</h2>

        <div class="navigation-links">
            <a href="index.html">‚ö° Campo El√©trico</a> |
            <a href="campo_magnetico.html">üß≠ Campo Magn√©tico</a>
        </div>
        <div class="main-content">
            <div class="simulation-panel">
                <canvas id="canvas" width="800" height="800"></canvas>
                <div class="controls">
                    <div class="control-group charge1">
                        <h3>‚ö° Carga 1</h3>
                        <label>Intensidade (ŒºC): <span class="value-display" id="q1-value">3.0</span></label>
                        <input type="range" id="q1" min="-5" max="5" step="0.1" value="3">
                        <label>Posi√ß√£o X: <span class="value-display" id="x1-value">-3.0</span></label>
                        <input type="range" id="x1" min="-8" max="8" step="0.1" value="-3">
                        <label>Posi√ß√£o Y: <span class="value-display" id="y1-value">0.0</span></label>
                        <input type="range" id="y1" min="-8" max="8" step="0.1" value="0">
                    </div>
                    <div class="control-group charge2">
                        <h3>‚ö° Carga 2</h3>
                        <label>Intensidade (ŒºC): <span class="value-display" id="q2-value">-3.0</span></label>
                        <input type="range" id="q2" min="-5" max="5" step="0.1" value="-3">
                        <label>Posi√ß√£o X: <span class="value-display" id="x2-value">3.0</span></label>
                        <input type="range" id="x2" min="-8" max="8" step="0.1" value="3">
                        <label>Posi√ß√£o Y: <span class="value-display" id="y2-value">0.0</span></label>
                        <input type="range" id="y2" min="-8" max="8" step="0.1" value="0">
                    </div>
                    <div class="control-group charge3 hidden" id="charge3Controls">
                        <h3>‚ö° Carga 3</h3>
                        <label>Intensidade (ŒºC): <span class="value-display" id="q3-value">1.5</span></label>
                        <input type="range" id="q3" min="-5" max="5" step="0.1" value="1.5">
                        <label>Posi√ß√£o X: <span class="value-display" id="x3-value">0.0</span></label>
                        <input type="range" id="x3" min="-8" max="8" step="0.1" value="0">
                        <label>Posi√ß√£o Y: <span class="value-display" id="y3-value">4.0</span></label>
                        <input type="range" id="y3" min="-8" max="8" step="0.1" value="4">
                    </div>
                    <button id="pauseBtn" onclick="togglePause()">‚ñ∂Ô∏è Iniciar F√≠sica</button>
                </div>
            </div>
            <div class="flowchart-panel">
                <h3>üó∫Ô∏è O Mapa do Potencial</h3>
                <div class="flow-step"><strong>1. O que √© Potencial?</strong><p>Pense no potencial el√©trico como uma "altitude" no espa√ßo. Cargas positivas criam "montanhas" de potencial, enquanto cargas negativas criam "vales".</p></div>
                <div class="flow-step"><strong>2. Linhas Equipotenciais</strong><p>As linhas coloridas s√£o como as curvas de n√≠vel em um mapa topogr√°fico. Todos os pontos em uma mesma linha t√™m a mesma "altitude" el√©trica, ou seja, o mesmo potencial.</p></div>
                <div class="flow-step"><strong>3. Linhas de Campo (com setas!)</strong><p>As linhas tracejadas com setas mostram a dire√ß√£o e sentido do campo el√©trico, que √© a dire√ß√£o da for√ßa em uma carga de prova positiva. Elas sempre apontam do potencial mais alto para o mais baixo e s√£o perpendiculares √†s equipotenciais.</p></div>
                <div class="flow-step"><strong>4. Trabalho Nulo</strong><p>Mover uma carga de teste ao longo de uma linha equipotencial √© como andar em um terreno plano. N√£o custa energia! O trabalho realizado √© zero, pois n√£o h√° mudan√ßa na "altitude" (potencial).</p></div>
                <div class="flow-step"><strong>5. Gradiente de Potencial</strong><p>Onde as linhas equipotenciais est√£o mais pr√≥ximas, o "terreno" √© mais √≠ngreme, o que significa um campo el√©trico mais forte. Onde est√£o mais afastadas, o campo √© mais fraco.</p></div>
            </div>
        </div>
    </div>

    <script>
        // O JavaScript continua o mesmo da vers√£o anterior, sem altera√ß√µes.
        class Charge { constructor(q, x, y, vx = 0, vy = 0) { this.q = q; this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.mass = 1; } }
        const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); const k = 1.0, dt = 0.02, xLim = [-8, 8], yLim = [-8, 8];
        let charges = [ new Charge(3.0, -3, 0), new Charge(-3.0, 3, 0) ]; let simulationPaused = true;
        const controls = { q1: { el: document.getElementById('q1'), display: document.getElementById('q1-value'), charge: 0, prop: 'q' }, x1: { el: document.getElementById('x1'), display: document.getElementById('x1-value'), charge: 0, prop: 'x' }, y1: { el: document.getElementById('y1'), display: document.getElementById('y1-value'), charge: 0, prop: 'y' }, q2: { el: document.getElementById('q2'), display: document.getElementById('q2-value'), charge: 1, prop: 'q' }, x2: { el: document.getElementById('x2'), display: document.getElementById('x2-value'), charge: 1, prop: 'x' }, y2: { el: document.getElementById('y2'), display: document.getElementById('y2-value'), charge: 1, prop: 'y' }, q3: { el: document.getElementById('q3'), display: document.getElementById('q3-value'), charge: 2, prop: 'q' }, x3: { el: document.getElementById('x3'), display: document.getElementById('x3-value'), charge: 2, prop: 'x' }, y3: { el: document.getElementById('y3'), display: document.getElementById('y3-value'), charge: 2, prop: 'y' }, };
        Object.values(controls).forEach(c => { c.el.addEventListener('input', () => { if (charges[c.charge]) { const value = parseFloat(c.el.value); charges[c.charge][c.prop] = value; c.display.textContent = value.toFixed(1); if (c.prop === 'x' || c.prop === 'y') { charges[c.charge].vx = 0; charges[c.charge].vy = 0; } } }); });
        function toggleThirdCharge() { const controlsDiv = document.getElementById('charge3Controls'); const btn = document.getElementById('addChargeBtn'); if (charges.length === 3) { charges.pop(); controlsDiv.classList.add('hidden'); btn.textContent = '‚ûï Adicionar 3¬™ Carga'; speak('Terceira carga removida. Voltamos a explorar a intera√ß√£o entre duas cargas.'); } else { const newCharge = new Charge(1.5, 0, 4); charges.push(newCharge); controlsDiv.classList.remove('hidden'); btn.textContent = '‚ûñ Remover 3¬™ Carga'; speak('Uma terceira carga foi adicionada! Veja como o mapa de potencial ficou mais complexo.'); } }
        function getPotentialAt(x, y) { let potential = 0; for (const c of charges) { const dx = x - c.x; const dy = y - c.y; const r = Math.sqrt(dx * dx + dy * dy); if (r > 0.01) { potential += k * c.q / r; } } return potential; }
        function getElectricFieldAt(x, y) { let Ex = 0; let Ey = 0; for (const c of charges) { const dx = x - c.x; const dy = y - c.y; const r = Math.sqrt(dx * dx + dy * dy); if (r > 0.01) { const E_mag = k * c.q / (r * r); Ex += E_mag * dx / r; Ey += E_mag * dy / r; } } return { Ex, Ey }; }
        function drawArrow(ctx, fromX, fromY, toX, toY, color) { const headlen = 10; const angle = Math.atan2(toY - fromY, toX - fromX); ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6)); ctx.moveTo(toX, toY); ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6)); ctx.stroke(); }
        function drawEquipotentialsAndFieldLines() { const scaleX = canvas.width / (xLim[1] - xLim[0]); const scaleY = canvas.height / (yLim[1] - yLim[0]); const originX = canvas.width / 2; const originY = canvas.height / 2; const resolution = 10; const potentialGrid = []; const gridWidth = canvas.width / resolution; const gridHeight = canvas.height / resolution; const worldToCanvasX = (wx) => originX + wx * scaleX; const worldToCanvasY = (wy) => originY - wy * scaleY; const canvasToWorldX = (cx) => (cx - originX) / scaleX; const canvasToWorldY = (cy) => (originY - cy) / scaleY; for (let i = 0; i <= gridWidth; i++) { potentialGrid[i] = []; for (let j = 0; j <= gridHeight; j++) { const worldX = canvasToWorldX(i * resolution); const worldY = canvasToWorldY(j * resolution); potentialGrid[i][j] = getPotentialAt(worldX, worldY); } } const levels = []; for(let i = -20; i <= 20; i += 0.5) { if(i !== 0) levels.push(i); } ctx.lineWidth = 2.5; levels.forEach(level => { ctx.beginPath(); const alpha = 0.3 + Math.min(0.7, Math.abs(level / 8)); const positiveColor = `rgba(255, 0, 0, ${alpha})`; const negativeColor = `rgba(0, 0, 255, ${alpha})`; ctx.strokeStyle = level > 0 ? positiveColor : negativeColor; for (let i = 0; i < gridWidth; i++) { for (let j = 0; j < gridHeight; j++) { const p = [ { x: i * resolution, y: j * resolution, v: potentialGrid[i][j] }, { x: (i + 1) * resolution, y: j * resolution, v: potentialGrid[i+1][j] }, { x: (i + 1) * resolution, y: (j + 1) * resolution, v: potentialGrid[i+1][j+1] }, { x: i * resolution, y: (j + 1) * resolution, v: potentialGrid[i][j+1] } ]; let caseIndex = 0; if (p[0].v > level) caseIndex |= 1; if (p[1].v > level) caseIndex |= 2; if (p[2].v > level) caseIndex |= 4; if (p[3].v > level) caseIndex |= 8; const interp = (p1, p2) => { if (Math.abs(level - p1.v) < 1e-6) return p1; if (Math.abs(level - p2.v) < 1e-6) return p2; if (Math.abs(p1.v - p2.v) < 1e-6) return p1; const t = (level - p1.v) / (p2.v - p1.v); return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) }; }; const a = interp(p[0], p[1]); const b = interp(p[1], p[2]); const c = interp(p[2], p[3]); const d = interp(p[3], p[0]); switch (caseIndex) { case 1: case 14: ctx.moveTo(d.x, d.y); ctx.lineTo(a.x, a.y); break; case 2: case 13: ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); break; case 3: case 12: ctx.moveTo(d.x, d.y); ctx.lineTo(b.x, b.y); break; case 4: case 11: ctx.moveTo(b.x, b.y); ctx.lineTo(c.x, c.y); break; case 5: ctx.moveTo(d.x, d.y); ctx.lineTo(a.x, a.y); ctx.moveTo(c.x, c.y); ctx.lineTo(b.x, b.y); break; case 6: case 9: ctx.moveTo(a.x, a.y); ctx.lineTo(c.x, c.y); break; case 7: case 8: ctx.moveTo(d.x, d.y); ctx.lineTo(c.x, c.y); break; case 10: ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.moveTo(d.x, d.y); ctx.lineTo(c.x, c.y); break; } } } ctx.stroke(); }); ctx.strokeStyle = "rgba(100, 100, 100, 0.7)"; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); const fieldLineDensity = 30; const stepSize = 0.2; charges.forEach(charge => { for (let i = 0; i < fieldLineDensity; i++) { let angle = (2 * Math.PI / fieldLineDensity) * i; if (charge.q < 0) angle += Math.PI; let x_start = charge.x + 0.1 * Math.cos(angle); let y_start = charge.y + 0.1 * Math.sin(angle); let currentX = x_start; let currentY = y_start; ctx.beginPath(); ctx.moveTo(worldToCanvasX(currentX), worldToCanvasY(currentY)); for (let step = 0; step < 200; step++) { const { Ex, Ey } = getElectricFieldAt(currentX, currentY); const E_mag = Math.sqrt(Ex * Ex + Ey * Ey); if (E_mag === 0 || isNaN(E_mag) || E_mag < 0.01) break; const normEx = Ex / E_mag; const normEy = Ey / E_mag; let nextX = currentX + normEx * stepSize; let nextY = currentY + normEy * stepSize; if (nextX < xLim[0] || nextX > xLim[1] || nextY < yLim[0] || nextY > yLim[1]) break; ctx.lineTo(worldToCanvasX(nextX), worldToCanvasY(nextY)); if (step % 10 === 0 && step > 0) { ctx.stroke(); drawArrow(ctx, worldToCanvasX(currentX), worldToCanvasY(currentY), worldToCanvasX(nextX), worldToCanvasY(nextY), "rgba(100, 100, 100, 0.7)"); ctx.beginPath(); ctx.moveTo(worldToCanvasX(nextX), worldToCanvasY(nextY)); } currentX = nextX; currentY = nextY; } ctx.stroke(); } }); ctx.setLineDash([]); }
        function updatePhysics() { if (simulationPaused) return; const forces = charges.map(() => ({ fx: 0, fy: 0 })); for (let i = 0; i < charges.length; i++) { for (let j = i + 1; j < charges.length; j++) { const c1 = charges[i], c2 = charges[j]; const dx = c2.x - c1.x, dy = c2.y - c1.y; const r2 = dx * dx + dy * dy; if (r2 < 0.1) continue; const r = Math.sqrt(r2); const forceMag = -k * c1.q * c2.q / r2; const fx = forceMag * dx / r, fy = forceMag * dy / r; forces[i].fx -= fx; forces[i].fy -= fy; forces[j].fx += fx; forces[j].fy += fy; } } charges.forEach((c, i) => { const ax = forces[i].fx / c.mass, ay = forces[i].fy / c.mass; c.vx += ax * dt; c.vy += ay * dt; c.x += c.vx * dt; c.y += c.vy * dt; if (c.x < xLim[0] || c.x > xLim[1]) c.vx *= -0.8; if (c.y < yLim[0] || c.y > yLim[1]) c.vy *= -0.8; c.x = Math.max(xLim[0], Math.min(xLim[1], c.x)); c.y = Math.max(yLim[0], Math.min(yLim[1], c.y)); const controlId = i + 1; if(controls['x' + controlId]) { controls['x' + controlId].el.value = c.x; controls['x' + controlId].display.textContent = c.x.toFixed(1); controls['y' + controlId].el.value = c.y; controls['y' + controlId].display.textContent = c.y.toFixed(1); } }); }
        function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "#f8f9fa"; ctx.fillRect(0, 0, canvas.width, canvas.height); updatePhysics(); drawEquipotentialsAndFieldLines(); const scaleX = canvas.width / (xLim[1] - xLim[0]), scaleY = canvas.height / (yLim[1] - yLim[0]); const originX = canvas.width / 2, originY = canvas.height / 2; charges.forEach((c) => { ctx.beginPath(); const canvasX = originX + c.x * scaleX; const canvasY = originY - c.y * scaleY; const radius = 18; ctx.arc(canvasX, canvasY, radius, 0, 2 * Math.PI); ctx.fillStyle = c.q > 0 ? "#ff4757" : "#3742fa"; ctx.fill(); ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = "white"; ctx.font = "bold 20px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(c.q > 0 ? "+" : "‚àí", canvasX, canvasY); }); requestAnimationFrame(draw); }
        function togglePause() { simulationPaused = !simulationPaused; document.getElementById('pauseBtn').textContent = simulationPaused ? '‚ñ∂Ô∏è Iniciar F√≠sica' : '‚è∏Ô∏è Pausar F√≠sica'; }
        let currentSpeech = null; function speak(text) { stopSpeaking(); if ('speechSynthesis' in window) { currentSpeech = new SpeechSynthesisUtterance(text.trim().replace(/\s+/g, ' ')); currentSpeech.lang = 'pt-BR'; currentSpeech.rate = 1; const avatarContainer = document.getElementById('avatar-container'); avatarContainer.classList.add('speaking'); currentSpeech.onend = () => avatarContainer.classList.remove('speaking'); window.speechSynthesis.speak(currentSpeech); } else { alert('Seu navegador n√£o suporta a fun√ß√£o de fala.'); } } function stopSpeaking() { window.speechSynthesis.cancel(); document.getElementById('avatar-container').classList.remove('speaking'); }
        function explainSimulation() { speak(`Ol√°! Bem-vindo ao mapa do potencial el√©trico! As cargas positivas criam 'montanhas' de energia, representadas em vermelho. As negativas criam 'vales', em azul. As linhas coloridas s√£o as linhas equipotenciais, conectando pontos de mesma 'altitude' el√©trica. E agora, as linhas tracejadas com setas, s√£o as linhas de campo el√©trico! Elas mostram a dire√ß√£o da for√ßa em uma carga positiva de teste e s√£o sempre perpendiculares √†s nossas linhas equipotenciais. Fascinante, n√£o?`); }
        function explainFlowchart() { speak(`O fluxograma explica nosso mapa. Primeiro: Potencial √© como a altitude de um terreno. Cargas positivas criam montanhas, negativas criam vales. Segundo: As linhas equipotenciais s√£o as curvas de n√≠vel, conectando pontos de mesma altitude. Terceiro: As linhas de campo el√©trico com setas mostram a dire√ß√£o da for√ßa. Elas sempre apontam do potencial mais alto para o mais baixo e s√£o perpendiculares √†s equipotenciais. Quarto: Andar sobre uma linha equipotencial n√£o gasta energia, o trabalho √© zero! E por √∫ltimo: Onde as linhas equipotenciais est√£o mais pr√≥ximas, o campo el√©trico √© mais forte, como uma descida √≠ngreme. Que tal experimentar?`); }
        draw();
    </script>
</body>
</html>
